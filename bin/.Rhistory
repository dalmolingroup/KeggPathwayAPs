createOrgList(funcDir = funcDir, orgList = orgList)
# Download the XML files from KEGG
# Parameters:
#   dirBase - name of your work folder
#   simProcesses - number of simultaneous download processes
#   dataType - KEGG database to download. Use "ec" for ec and "ko" for ko
#   organisms - list of organisms to download. Use <some> for the organisms
#     inside your orgList or <all> for all organisms in KEGG.
#     Edit the orgList above for personalized organisms
#   skip - don't execute this phase and a downloaded data
#     to execute your own download change skip to F
# The ec XML files  are necessary to generate the dictionary of nodes.
# Skip if using our pre downloaded ec XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ec",
skip = T)
# Download the organims XML files
# Skip if using our hsa and mmu pre downloaded XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ko",
organisms = "some",
skip = T)
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = F)
dataType = "ec" #debug
if(skip){
cat("Skiping", dataType,  "pathways processing... \n\n")
return(0)
}
logFile <<- file.path(dirBase,"log","phase2.log")
cat("Starting", dataType,  "pathways processing... \n\n")
cat(file = logFile, append = T,
"\n\n ***************************************************\n",
"Starting", dataType,  "pathways processing...\n",
date(),"\n",
"***************************************************\n\n")
workDir<-file.path(dirBase,"data","kgml")
filterDir<-file.path(dirBase,"data","filtredKgml",dataType)
if(!dir.exists(filterDir)){
dir.create(filterDir, recursive = T)
}
dbDir<-file.path(dirBase,"data","database")
dbTemplate<-file.path(dbDir,"dictionaryTemplate.db")
dbFile<-file.path(dbDir,"dictionary.db")
# Define the reference pathway
if(dataType == 'ec'){
folders <- file.path(workDir,"ec")
#check if db folder not exists and create it
if(!dir.exists(dbDir)){
dir.create(dbDir)
}
#conect and test dictionary
dbCon <<- dbConnect(RSQLite::SQLite(), dbFile)
#check if is an empty db. If it is, copy from template
if(length(dbListTables(dbCon)) == 0){
dbDisconnect(dbCon)
if(file.exists(dbTemplate)){
file.copy(dbTemplate, dbFile, overwrite = T)
}else{
stop("Database template is missing. Please download it from github...")
}
dbCon <<- dbConnect(RSQLite::SQLite(), dbFile)
}
}else{
#list all folders
folders<-list.dirs(workDir,full.names = T)
#remove ec and kgml folders
folders<-folders[!folders %in% c(workDir,
file.path(workDir,"ec"))]
}
folder<- folders[1] #debug
# Get the list of files
#folder = file.path("./output/kgml/", reference_pathway, "/")
kgml_list <- list.files(path=folder, pattern='*.xml')
# xmllist ----
#*********************************************************************************#
# IMPORTANTE: Aqui estou reduzindo a lista das pathways para não ficar tão pesado!
#*********************************************************************************#
#kgml_list = c('ec00010.xml', 'ec00520.xml') #debug
kgml_list = c('ec00121.xml') #debug
kgml_index <- 1
# Define the number of available pathways
available_pathways <- length(kgml_list)
# Check if the folder contains files
if (is.null(kgml_list) | length(kgml_list) == 0) {
# Status message
stop("There aren't available pathways...")
return(FALSE)
}
file = kgml_list[1] #debug
kgml_<-file.path(folder, file) #debug
error <<- 0
tryCatch(doc <- read_xml(kgml_, getDTD = FALSE, error = xmlErrorCumulator(immediate = FALSE)),
error = function(e) {
fileSize <- file.info(kgml_)$size[1]
bytes <- sprintf("%d byte%s", fileSize, ifelse(fileSize >
1, "s", ""))
msg <- paste("The file", kgml_, "seems not to be a valid KGML file\n")
if (fileSize < 100L)
msg <- paste(msg, "[WARNING] File size (", bytes,
") is unsually small; please check.\n", sep = "")
msg <- paste(msg, "\nDetailed error messages from",
"XML::xmlTreeParse:\n", sep = "")
cat(msg)
stop(e)
})
# Retrieve the XML root
root <- xml_root(doc)
# Define which children are entries
isEntry<-xml_find_all(root,"//entry")
# Define which children are relations
isRelation<-xml_find_all(root,"//relation")
# Define which children are reactions
isReaction<-xml_find_all(root,"//reaction")
# Retrieve the pathway info as dataFrame
pathwayinfo <- parsePathwayInfo(root)
map <- sub(x = pathwayinfo$name, pattern = "path:",replacement = '')
entry<-xml_find_first(root,"//entry[@name='ec:2.7.1.1']") #debug
#entry<-isEntry[[1]] #debug
# Retrieve the pathway entries as dataFrame
tryCatch(dataList <- lapply(isEntry, parseEntry),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-0
return(NULL)
})
#entry<-isEntry[[1]] #debug
# Retrieve the pathway entries as dataFrame
tryCatch(dataList <- lapply(isEntry, parseEntry),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
error != 0
error != 0
#entry<-isEntry[[1]] #debug
# Retrieve the pathway entries as dataFrame
tryCatch(dataList <- lapply(isEntry, parseEntry),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
#rearange in dataframes
entryRef <- do.call(rbind, lapply(dataList, `[[`, 1))
entryMap <- do.call(rbind, lapply(dataList, `[[`, 2))
dupEntry <- do.call(rbind, lapply(dataList, `[[`, 3))
dupEntry<-na.exclude(dupEntry)
eDupReaction <- do.call(rbind, lapply(dataList, `[[`, 4))
eDupReaction<-na.exclude(eDupReaction)
rm(dataList)
relation<-xml_find_first(root,"//relation") #debug
# Retrieve the pathway edges as dataFrame
tryCatch(dataList <- lapply(isRelation, parseRelation),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
error != 0
if(error != 0){
return(0)
}
relationRef <- do.call(rbind, dataList)
rm(dataList)
tryCatch(dataList <- lapply(isReaction, parseReaction),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-0
error<<-1
return(NULL)
})
error != 0
if(error != 0){
return(0)
}
# reactions <- do.call(rbind, dataList)
reactionsRef <- do.call(rbind, lapply(dataList, `[[`, 1))
reactionsDef <- do.call(rbind, lapply(dataList, `[[`, 2))
rDupReaction <- do.call(rbind, lapply(dataList, `[[`, 3))
rDupReaction<-na.exclude(rDupReaction)
rm(dataList)
#separate enzimes from maps and compounds
enzimes<-entryRef[entryRef$eType == 'enzyme',]
compounds<-entryRef[entryRef$eType == 'compound',]
compounds$cDesc<-''
# To maintain always the lower name
enzimes<-enzimes[order(enzimes$eName),]
#colapse alternative enzimes for the same reaction
nodes<-enzimes[!duplicated(enzimes[,c("eReaction")]),]
nodesDuplic<-enzimes[duplicated(enzimes[,c("eReaction")]),]
nodesDuplic<- merge(nodesDuplic, nodes[,c("eId","eName",
"eReaction",
"x","y")],
by="eReaction")
#nodes<-current_kgml$nodes
map <- pathwayinfo$number
i=2 #debug
#something is wrong with data?
if(isTRUE(is.null(nrow(compounds))) |
isTRUE(nrow(compounds) == 0) |
isTRUE(is.null(nrow(reactionsRef))) |
isTRUE(nrow(reactionsRef) == 0)|
isTRUE(is.null(nrow(enzimes))) |
isTRUE(nrow(enzimes) == 0) |
isTRUE(is.null(nrow(relationRef))) |
isTRUE(nrow(relationRef) == 0)){
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
return(0)
}
#*************************************************
#   ATTENTION!!! This code is provided "AS-IS",
#   with no warranties, express or implied, and
#   hereby disclaims all implied warranties,
#   including any warranty of merchantability and
#   warranty of fitness for a particular purpose.
#   It's released under GPL v2.
#*************************************************
#*************************************************
# Updated in 19/11/2020
#*************************************************
#main ----
# ver rota 00061
#Clean all variables ----
rm(list=ls(all=TRUE))
#Base location ----
#Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<-"/home/clovis/Dropbox/projetos/Igor/gitAPs"
#figures
dirFig<-file.path(dirBase,"figures")
#bin dir
binDir<-file.path(dirBase,"bin")
#function dir
funcDir<-file.path(binDir,"functions")
#Organisms to process
#Put here your list of organisms inside the '...' separated by space and "..." as delimiter
orgList<-'"hsa" "mmu"'
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Create the organisms list to be processed
createOrgList(funcDir = funcDir, orgList = orgList)
# Download the XML files from KEGG
# Parameters:
#   dirBase - name of your work folder
#   simProcesses - number of simultaneous download processes
#   dataType - KEGG database to download. Use "ec" for ec and "ko" for ko
#   organisms - list of organisms to download. Use <some> for the organisms
#     inside your orgList or <all> for all organisms in KEGG.
#     Edit the orgList above for personalized organisms
#   skip - don't execute this phase and a downloaded data
#     to execute your own download change skip to F
# The ec XML files  are necessary to generate the dictionary of nodes.
# Skip if using our pre downloaded ec XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ec",
skip = T)
# Download the organims XML files
# Skip if using our hsa and mmu pre downloaded XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ko",
organisms = "some",
skip = T)
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = F)
processed <<- 0
processed <<- processed + 1
cat("Processing",
file,
'[',processed,'/',
available_pathways,']\n')
# Define the number of available pathways
available_pathways <- length(kgml_list)
#*************************************************
#   ATTENTION!!! This code is provided "AS-IS",
#   with no warranties, express or implied, and
#   hereby disclaims all implied warranties,
#   including any warranty of merchantability and
#   warranty of fitness for a particular purpose.
#   It's released under GPL v2.
#*************************************************
#*************************************************
# Updated in 19/11/2020
#*************************************************
#main ----
# ver rota 00061
#Clean all variables ----
rm(list=ls(all=TRUE))
#Base location ----
#Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<-"/home/clovis/Dropbox/projetos/Igor/gitAPs"
#figures
dirFig<-file.path(dirBase,"figures")
#bin dir
binDir<-file.path(dirBase,"bin")
#function dir
funcDir<-file.path(binDir,"functions")
#Organisms to process
#Put here your list of organisms inside the '...' separated by space and "..." as delimiter
orgList<-'"hsa" "mmu"'
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Create the organisms list to be processed
createOrgList(funcDir = funcDir, orgList = orgList)
# Download the XML files from KEGG
# Parameters:
#   dirBase - name of your work folder
#   simProcesses - number of simultaneous download processes
#   dataType - KEGG database to download. Use "ec" for ec and "ko" for ko
#   organisms - list of organisms to download. Use <some> for the organisms
#     inside your orgList or <all> for all organisms in KEGG.
#     Edit the orgList above for personalized organisms
#   skip - don't execute this phase and a downloaded data
#     to execute your own download change skip to F
# The ec XML files  are necessary to generate the dictionary of nodes.
# Skip if using our pre downloaded ec XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ec",
skip = T)
# Download the organims XML files
# Skip if using our hsa and mmu pre downloaded XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ko",
organisms = "some",
skip = T)
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = F)
#*************************************************
#   ATTENTION!!! This code is provided "AS-IS",
#   with no warranties, express or implied, and
#   hereby disclaims all implied warranties,
#   including any warranty of merchantability and
#   warranty of fitness for a particular purpose.
#   It's released under GPL v2.
#*************************************************
#*************************************************
# Updated in 19/11/2020
#*************************************************
#main ----
# ver rota 00061
#Clean all variables ----
rm(list=ls(all=TRUE))
#Base location ----
#Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<<-"/home/clovis/Dropbox/projetos/Igor/gitAPs"
#figures
dirFig<<-file.path(dirBase,"figures")
#bin dir
binDir<<-file.path(dirBase,"bin")
#function dir
funcDir<<-file.path(binDir,"functions")
#database folder and file
dbDir<<-file.path(dirBase,"data","database")
dbFile<<-file.path(dbDir,"dictionary.db")
#Organisms to process
#Put here your list of organisms inside the '...' separated by space and "..." as delimiter
orgList<-'"hsa" "mmu"'
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Create the organisms list to be processed
createOrgList(funcDir = funcDir, orgList = orgList)
# Download the XML files from KEGG
# Parameters:
#   dirBase - name of your work folder
#   simProcesses - number of simultaneous download processes
#   dataType - KEGG database to download. Use "ec" for ec and "ko" for ko
#   organisms - list of organisms to download. Use <some> for the organisms
#     inside your orgList or <all> for all organisms in KEGG.
#     Edit the orgList above for personalized organisms
#   skip - don't execute this phase and a downloaded data
#     to execute your own download change skip to F
# The ec XML files  are necessary to generate the dictionary of nodes.
# Skip if using our pre downloaded ec XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ec",
skip = T)
# Download the organims XML files
# Skip if using our hsa and mmu pre downloaded XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ko",
organisms = "some",
skip = T)
#create a new empty database
# WARNING: all data will be lost
createDB(skip = T)
# read xml files and load data to database
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = T)
createNodesFromEC(dirBase = dirBase, skip = T)
showGraph(pathway = "ec:00365", plot = T)
#*************************************************
#   ATTENTION!!! This code is provided "AS-IS",
#   with no warranties, express or implied, and
#   hereby disclaims all implied warranties,
#   including any warranty of merchantability and
#   warranty of fitness for a particular purpose.
#   It's released under GPL v2.
#*************************************************
#*************************************************
# Updated in 19/11/2020
#*************************************************
#main ----
# ver rota 00061
#Clean all variables ----
rm(list=ls(all=TRUE))
#Base location ----
#Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<<-"/home/clovis/Dropbox/projetos/Igor/gitAPs"
#figures
dirFig<<-file.path(dirBase,"figures")
#bin dir
binDir<<-file.path(dirBase,"bin")
#function dir
funcDir<<-file.path(binDir,"functions")
#database folder and file
dbDir<<-file.path(dirBase,"data","database")
dbFile<<-file.path(dbDir,"dictionary.db")
#Organisms to process
#Put here your list of organisms inside the '...' separated by space and "..." as delimiter
orgList<-'"hsa" "mmu"'
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Create the organisms list to be processed
createOrgList(funcDir = funcDir, orgList = orgList)
# Download the XML files from KEGG
# Parameters:
#   dirBase - name of your work folder
#   simProcesses - number of simultaneous download processes
#   dataType - KEGG database to download. Use "ec" for ec and "ko" for ko
#   organisms - list of organisms to download. Use <some> for the organisms
#     inside your orgList or <all> for all organisms in KEGG.
#     Edit the orgList above for personalized organisms
#   skip - don't execute this phase and a downloaded data
#     to execute your own download change skip to F
# The ec XML files  are necessary to generate the dictionary of nodes.
# Skip if using our pre downloaded ec XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ec",
skip = T)
# Download the organims XML files
# Skip if using our hsa and mmu pre downloaded XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ko",
organisms = "some",
skip = T)
#create a new empty database
# WARNING: all data will be lost
createDB(skip = T)
# read xml files and load data to database
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = T)
createNodesFromEC(dirBase = dirBase, skip = T)
showGraph(pathway = "ec:00365", plot = T)
showGraph(pathway = "ec00365", plot = T)
showGraph(pathway = "ec00190", plot = T)
showGraph(pathway = "ec00190", plot = T)
showGraph(pathway = "ec00253", plot = T)
showGraph(pathway = "ec00604", plot = T)
showGraph(pathway = "ec00300", plot = T)
ecs<-c('ec:5.1.3.3','ec:2.7.1.2','ec:2.7.1.147',
'ec:5.1.3.15','ec:5.3.1.9','ec:2.7.1.199',
'ec:2.7.1.63','ec::2.7.1.1','ec:3.1.3.10',
'ec:3.1.3.9','ec:5.4.2.2')
showGraph(pathway = "ec00010", ecs = ecs, plot = T)
ecs<-c('ec:5.1.3.3','ec:2.7.1.147',
'ec:5.1.3.15','ec:5.3.1.9','ec:2.7.1.199',
'ec:2.7.1.63','ec::2.7.1.1','ec:3.1.3.10',
'ec:3.1.3.9','ec:5.4.2.2')
showGraph(pathway = "ec00010", ecs = ecs, plot = T)
ecs<-c('ec:5.1.3.3','ec:2.7.1.147',
'ec:5.1.3.15','ec:5.3.1.9','ec:2.7.1.199',
'ec::2.7.1.1','ec:3.1.3.10',
'ec:3.1.3.9','ec:5.4.2.2')
showGraph(pathway = "ec00010", ecs = ecs, plot = T)
