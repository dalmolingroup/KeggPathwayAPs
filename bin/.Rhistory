print(sql)
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
return(resQuery[[1]][[1]])
}
}
getNodeMetrics(V(g4)$nId, pId)
searchValue <- function(table, fields, values) {
if (length(fields) != length(values)) {
stop("Fields and values must have same length.")
}
# Close and reopen the DB connection
closeDb <<- F
createDbConnection()
# Format the SQL query
sql <- paste0('SELECT * FROM ', table, ' WHERE ')
# Add the query values
if (typeof(values) == 'list') {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
# Check how many items is inside the current value
currentValue = values[[idx]]
if (length(currentValue) == 1) {
# Single value
sql <- paste0(sql, fields[idx], ' = ', currentValue)
} else if (length(currentValue) > 1) {
# Multiple values
sql <- paste0(sql, fields[idx], ' IN (')
# Loop over the values
for (idx2 in 1:length(currentValue)) {
if (idx2 == (length(currentValue) - 1)) {
sql <- paste0(sql, currentValue[idx2])
} else {
sql <- paste0(sql, currentValue[idx2], ', ')
}
}
sql <- paste0(sql, ')')
}
# If there are more where clauses
if (idx != length(fields)) {
sql<- paste0(sql,' and ')
}
}
} else {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
sql<- paste0(sql,fields[idx],' = ',values[idx])
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
}
print(sql)
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
return(resQuery[[1]][[1]])
}
}
getNodeMetrics(V(g4)$nId, pId)
searchValue <- function(table, fields, values) {
if (length(fields) != length(values)) {
stop("Fields and values must have same length.")
}
# Close and reopen the DB connection
closeDb <<- F
createDbConnection()
# Format the SQL query
sql <- paste0('SELECT * FROM ', table, ' WHERE ')
# Add the query values
if (typeof(values) == 'list') {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
# Check how many items is inside the current value
currentValue = values[[idx]]
if (length(currentValue) == 1) {
# Single value
sql <- paste0(sql, fields[idx], ' = ', currentValue)
} else if (length(currentValue) > 1) {
# Multiple values
sql <- paste0(sql, fields[idx], ' IN (')
# Loop over the values
for (idx2 in 1:length(currentValue)) {
if (idx2 == length(currentValue)) {
sql <- paste0(sql, currentValue[idx2])
} else {
sql <- paste0(sql, currentValue[idx2], ', ')
}
}
# Finalize the query
sql <- paste0(sql, ')')
}
# If there are more where clauses
if (idx != length(fields)) {
sql<- paste0(sql,' and ')
}
}
} else {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
sql<- paste0(sql,fields[idx],' = ',values[idx])
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
}
print(sql)
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
return(resQuery[[1]][[1]])
}
}
getNodeMetrics(V(g4)$nId, pId)
getPathId(pathway_)
searchValue <- function(table, fields, values) {
if (length(fields) != length(values)) {
stop("Fields and values must have same length.")
}
# Close and reopen the DB connection
closeDb <<- F
createDbConnection()
# Format the SQL query
sql <- paste0('SELECT * FROM ', table, ' WHERE ')
# Add the query values
if (typeof(values) == 'list') {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
# Check how many items is inside the current value
currentValue = values[[idx]]
if (length(currentValue) == 1) { # Single value
sql <- paste0(sql, fields[idx], ' = ', currentValue)
} else if (length(currentValue) > 1) { # Multiple values
sql <- paste0(sql, fields[idx], ' IN (')
# Loop over the values
for (idx2 in 1:length(currentValue)) {
if (idx2 == length(currentValue)) {
sql <- paste0(sql, currentValue[idx2])
} else {
sql <- paste0(sql, currentValue[idx2], ', ')
}
}
# Finalize the query
sql <- paste0(sql, ')')
}
# If there are more where clauses
if (idx != length(fields)) {
sql<- paste0(sql,' and ')
}
}
} else {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
sql<- paste0(sql,fields[idx],' = ',values[idx])
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
}
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
return(resQuery[[1]][[1]])
}
}
getNodeMetrics(V(g4)$nId, pId)
searchValue <- function(table, fields, values) {
if (length(fields) != length(values)) {
stop("Fields and values must have same length.")
}
# Close and reopen the DB connection
closeDb <<- F
createDbConnection()
# Format the SQL query
sql <- paste0('SELECT * FROM ', table, ' WHERE ')
# Add the query values
if (typeof(values) == 'list') {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
# Check how many items is inside the current value
currentValue = values[[idx]]
if (length(currentValue) == 1) { # Single value
sql <- paste0(sql, fields[idx], ' = ', currentValue)
} else if (length(currentValue) > 1) { # Multiple values
sql <- paste0(sql, fields[idx], ' IN (')
# Loop over the values
for (idx2 in 1:length(currentValue)) {
if (idx2 == length(currentValue)) {
sql <- paste0(sql, currentValue[idx2])
} else {
sql <- paste0(sql, currentValue[idx2], ', ')
}
}
# Finalize the query
sql <- paste0(sql, ')')
}
# If there are more where clauses
if (idx != length(fields)) {
sql<- paste0(sql,' and ')
}
}
} else {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
sql<- paste0(sql,fields[idx],' = ',values[idx])
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
}
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
print(resQuery)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
return(resQuery[[1]][[1]])
}
}
getNodeMetrics(V(g4)$nId, pId)
searchValue <- function(table, fields, values) {
if (length(fields) != length(values)) {
stop("Fields and values must have same length.")
}
# Close and reopen the DB connection
closeDb <<- F
createDbConnection()
# Format the SQL query
sql <- paste0('SELECT * FROM ', table, ' WHERE ')
# Add the query values
if (typeof(values) == 'list') {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
# Check how many items is inside the current value
currentValue = values[[idx]]
if (length(currentValue) == 1) { # Single value
sql <- paste0(sql, fields[idx], ' = ', currentValue)
} else if (length(currentValue) > 1) { # Multiple values
sql <- paste0(sql, fields[idx], ' IN (')
# Loop over the values
for (idx2 in 1:length(currentValue)) {
if (idx2 == length(currentValue)) {
sql <- paste0(sql, currentValue[idx2])
} else {
sql <- paste0(sql, currentValue[idx2], ', ')
}
}
# Finalize the query
sql <- paste0(sql, ')')
}
# If there are more where clauses
if (idx != length(fields)) {
sql<- paste0(sql,' and ')
}
}
} else {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
sql<- paste0(sql,fields[idx],' = ',values[idx])
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
}
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
return(resQuery)
}
}
getPathId(pathway_)
getNodeMetrics(V(g4)$nId, pId)
searchValue <- function(table, fields, values, allData = F) {
if (length(fields) != length(values)) {
stop("Fields and values must have same length.")
}
# Close and reopen the DB connection
closeDb <<- F
createDbConnection()
# Format the SQL query
sql <- paste0('SELECT * FROM ', table, ' WHERE ')
# Add the query values
if (typeof(values) == 'list') {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
# Check how many items is inside the current value
currentValue = values[[idx]]
if (length(currentValue) == 1) { # Single value
sql <- paste0(sql, fields[idx], ' = ', currentValue)
} else if (length(currentValue) > 1) { # Multiple values
sql <- paste0(sql, fields[idx], ' IN (')
# Loop over the values
for (idx2 in 1:length(currentValue)) {
if (idx2 == length(currentValue)) {
sql <- paste0(sql, currentValue[idx2])
} else {
sql <- paste0(sql, currentValue[idx2], ', ')
}
}
# Finalize the query
sql <- paste0(sql, ')')
}
# If there are more where clauses
if (idx != length(fields)) {
sql<- paste0(sql,' and ')
}
}
} else {
# Loop over the where fields and values
for (idx in 1:length(fields)) {
sql<- paste0(sql,fields[idx],' = ',values[idx])
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
}
# Execute the query
resQuery <- dbGetQuery(dbCon, sql)
#cat(sql,' ',nrow(resQuery),'\n')
if (nrow(resQuery)==0) {
return(0)
} else {
if (!allData) {
return(resQuery[[1]][[1]])
} else {
return(resQuery)
}
}
}
getPathId(pathway_)
getNodeMetrics(V(g4)$nId, pId)
getNodeMetrics(V(g4)$nId, pId, allData=T)
getNodeMetrics <- function(nodeIds_, pathwayId_) {
# DB attributes
table <- "nodemetric"
whereFields <- c("nId", "pId")
# Search in DB
resQuery <- searchValue(table, whereFields, list(nodeIds_, pathwayId_), allData=T)
# Check if at least one pathway was returned
if (is.null(resQuery) || length(resQuery) == 0) {
stop("Nodes not found!")
}
return(resQuery)
}
getNodeMetrics(V(g4)$nId, pId)
getPathId(pathway_)
# Retrieve the network metrics
networkProperties <- getNodeMetrics(V(g4)$nId, pId)
View(networkProperties)
#Clean all variables ----
rm(list=ls(all=TRUE))
# Define base dir ----
#Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<<-"/media/igorbrandao/IGOR BACKUP SERVER/Arquivos Igor/Faculdades/UFRN/4 - Mestrado/Pesquisas/System biology approaches in the investigation of bottlenecks in KEGG pathways/KeggPathwayAPs"
# bin dir
binDir<<-file.path(dirBase,"bin")
#function dir
funcDir<<-file.path(binDir,"functions")
#database folder and file
dbDir<<-file.path(dirBase,"data","database")
dbTemplate <- file.path(dbDir,"APs.sql")
dbFile<<-file.path(dbDir,"dictionary.db")
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
pathway_ = "ec00010"
auxInfo_ = T
label_ = "enzyme"
removeFake_ = T
if (!label_ %in% c('enzyme','reaction','id')) {
stop('Label must be "enzyme", "reaction" or "id".')
}
# Retrieve the pathway ID
pId = getPathId(pathway_)
# Retrieve the graph
lGraph <- getGraphFromPath(pathway = pathway_, removeFake = removeFake_, auxInfo = auxInfo_)
g1<-lGraph[[1]]
g4 <-lGraph[[2]]
# Retrieve the network metrics
networkProperties <- getNodeMetrics(V(g4)$nId, pId)
# Get the iGraph object
iGraph <- g4
# Convert the iGraph object toVisNetworkData
data <- toVisNetworkData(iGraph)
if (label == 'enzyme') {
edge_attr(g1,'label')<-edge_attr(g1,"eName")
vertex_attr(g4,'name')<-vertex_attr(g4,"eName")
} else if(label == 'reaction') {
edge_attr(g1,'label')<-edge_attr(g1,"rName")
vertex_attr(g4,'name')<-vertex_attr(g4,"rName")
}
if (label_ == 'enzyme') {
edge_attr(g1,'label')<-edge_attr(g1,"eName")
vertex_attr(g4,'name')<-vertex_attr(g4,"eName")
} else if(label_ == 'reaction') {
edge_attr(g1,'label')<-edge_attr(g1,"rName")
vertex_attr(g4,'name')<-vertex_attr(g4,"rName")
}
iGraph
# Color pallet
pal <- brewer.pal(9, "YlOrRd")
pal2 <- brewer.pal(8, "Dark2")
# Create vis object
vis.nodes <- networkProperties_
# Create vis object
vis.nodes <- networkProperties
vis.links <- data$edges
View(vis.nodes)
# Define the nodes group
vis.nodes$group = vis.nodes$isAP
if (sum(vis.nodes$group == 1, na.rm = T) > 0) {
vis.nodes[vis.nodes$group == 1,]$group <- 'AP'
}
if (sum(vis.nodes$group == 0, na.rm = T) > 0) {
vis.nodes[vis.nodes$group == 0,]$group <- 'Non-AP'
}
# Set the initial nodes attributes
vis.nodes$color.border <- "white"
vis.nodes$borderWidth <- 0
# Apply the border color by bottleneck status
vis.nodes$color.border[which(vis.nodes$isAP == 0)] <- "white"
vis.nodes$color.border[which(vis.nodes$isAP == 1)] <- "blue"
vis.nodes$borderWidth[which(vis.nodes$isAP == 0)] <- 2 # Node border width
vis.nodes$borderWidth[which(vis.nodes$isAP == 1)] <- 4 # AP Node border width
vis.nodes$dictID
vis.nodes$nId
vis.nodes$id     <- vis.nodes$nId # Node ID
V(g4)$nId
V(g4)$name
# Get the nodes name
vis.nodes$name = ''
vis.nodes[vis.nodes$nId == V(g4)$nId,]$name
vis.nodes[vis.nodes$nId == V(g4)$nId,]
V(g4)$nId
vis.nodes$nId == V(g4)$nId
V(g4)[0]$nId
V(g4)$nId[0]
vis.nodes$nId
V(g4)$nId
order(V(g4)$nId)
sort(V(g4)$nId)
vis.nodes[vis.nodes$nId == sort(V(g4)$nId),]
vis.nodes[sort(vis.nodes$nId) == sort(V(g4)$nId),]
sort(V(g4)$nId)
sort(V(g4))
sort(V(g4)$name)
sort(V(g4)$nId)
V(g4)[V(g4)$nId == sort(V(g4)$nId), ]$name
V(g4)$nId
sort(V(g4)$nId)
[V(g4)$nId == sort(V(g4)$nId),]
V(g4)$nId == sort(V(g4)$nId)
V(g4)[1]
V(g4)[2]
sort(V(g4)$nId)
length(vis.nodes)
vis.nodes
length(V(g4))
V(g4)[1]$nId
V(g4)[2]$nId
V(g4)[3]$nId
V(g4)[4]$nId
for (idx in 1:length(vis.nodes)) {
for (idx2 in 1:length(V(g4))) {
if (vis.nodes[idx]$nId == V(g4)[idx2]$nId) {
vis.nodes[idx]$name = V(g4)[idx2]$name
break
}
}
}
vis.nodes[idx]
idx
length(vis.nodes)
length(V(g4)
length(V(g4))
length(V(g4))
for (idx in 1:length(vis.nodes)) {
for (idx2 in 1:length(V(g4))) {
print(paste0(vis.nodes[idx]$nId, '== ', V(g4)[idx2]$nId))
if (vis.nodes[idx]$nId == V(g4)[idx2]$nId) {
vis.nodes[idx]$name = V(g4)[idx2]$name
break
}
}
}
for (idx in 1:length(vis.nodes)) {
for (idx2 in 1:length(V(g4))) {
print(paste0(vis.nodes[idx]$nId, '== ', V(g4)[idx2]$nId))
if (vis.nodes[idx]$nId == V(g4)[idx2]$nId) {
vis.nodes[idx]$name = V(g4)[idx2]$name
break
}
}
}
