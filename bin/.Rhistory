# Create the organisms list to be processed
createOrgList(funcDir = funcDir, orgList = orgList)
# Download the XML files from KEGG
# Parameters:
#   dirBase - name of your work folder
#   simProcesses - number of simultaneous download processes
#   dataType - KEGG database to download. Use "ec" for ec and "ko" for ko
#   organisms - list of organisms to download. Use <some> for the organisms
#     inside your orgList or <all> for all organisms in KEGG.
#     Edit the orgList above for personalized organisms
#   skip - don't execute this phase and a downloaded data
#     to execute your own download change skip to F
# The ec XML files  are necessary to generate the dictionary of nodes.
# Skip if using our pre downloaded ec XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ec",
skip = T)
# Download the organims XML files
# Skip if using our hsa and mmu pre downloaded XML files available on github
downloadKGML(dirBase = dirBase,
simProcesses = 1,
dataType = "ko",
organisms = "some",
skip = T)
#create a new empty database
# WARNING: all data will be lost
createDB(dbTemplate = dbTemplate,
dbFile = dbFile,
skip = T)
#to use a pre processed database execute this
# WARNING: all data overwrite by a previous version
unpackDB(dbDir = dbDir,
skip = T)
# read xml files and load data to database
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = T)
createNodesFromEC(dirBase = dirBase, skip = T)
createGraphMetrics(skip = T)
# read xml files from organisms and associate load data with ec networks
generateDataFromKGML(dirBase = dirBase,
dataType = 'orgs',
skip = F)
dataType = "ec"
workDir<-file.path(dirBase,"data","kgml")
filterDir<-file.path(dirBase,"data","filtredKgml",dataType)
if(!dir.exists(filterDir)){
dir.create(filterDir, recursive = T)
}
dbDir<-file.path(dirBase,"data","database")
dbTemplate<-file.path(dbDir,"APs.sql")
dbFile<-file.path(dbDir,"dictionary.db")
if(!dir.exists(dbDir)){
dir.create(dbDir)
}
#conect and test dictionary
dbCon <<- dbConnect(RSQLite::SQLite(), dbFile)
#check if is an empty db. If it is, copy from template
if(length(dbListTables(dbCon)) == 0){
dbDisconnect(dbCon)
if(file.exists(dbTemplate)){
# file.copy(dbTemplate, dbFile, overwrite = T)
createDB(dbTemplate, dbFile)
}else{
stop("Database template is missing. Please download it from github...")
}
dbCon <<- dbConnect(RSQLite::SQLite(), dbFile)
}
folder <- file.path(workDir,"ec")
# Get the list of files
kgml_list <- list.files(path=folder, pattern='*.xml')
kgml_index <- 1
# Define the number of available pathways
available_pathways <- length(kgml_list)
is.null(kgml_list) | length(kgml_list) == 0
file = kgml_list[1] #debug
processed <<- 0
kgml_<-file.path(folder, file) #debug
dataType
error <<- 0
tryCatch(doc <- read_xml(kgml_, getDTD = FALSE, error = xmlErrorCumulator(immediate = FALSE)),
error = function(e) {
fileSize <- file.info(kgml_)$size[1]
bytes <- sprintf("%d byte%s", fileSize, ifelse(fileSize >
1, "s", ""))
msg <- paste("The file", kgml_, "seems not to be a valid KGML file\n")
if (fileSize < 100L)
msg <- paste(msg, "[WARNING] File size (", bytes,
") is unsually small; please check.\n", sep = "")
msg <- paste(msg, "\nDetailed error messages from",
"XML::xmlTreeParse:\n", sep = "")
cat(msg)
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n",msg,'\n')
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
# Retrieve the XML root
root <- xml_root(doc)
# Define which children are entries
isEntry<-xml_find_all(root,"//entry")
# Define which children are relations
isRelation<-xml_find_all(root,"//relation")
# Define which children are reactions
isReaction<-xml_find_all(root,"//reaction")
# Retrieve the pathway info as dataFrame
pathwayinfo <- parsePathwayInfo(root)
map <- sub(x = pathwayinfo$name, pattern = "path:",replacement = '')
entry<-xml_find_first(root,"//entry[@name='ec:2.7.1.1']") #debug
#entry<-isEntry[[1]] #debug
# Retrieve the pathway entries as dataFrame
tryCatch(dataList <- lapply(isEntry, parseEntry),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
#rearange in dataframes
entryRef <- do.call(rbind, lapply(dataList, `[[`, 1))
entryMap <- do.call(rbind, lapply(dataList, `[[`, 2))
dupEntry <- do.call(rbind, lapply(dataList, `[[`, 3))
dupEntry<-na.exclude(dupEntry)
eDupReaction <- do.call(rbind, lapply(dataList, `[[`, 4))
eDupReaction<-na.exclude(eDupReaction)
View(entryMap)
rm(dataList)
relation<-xml_find_first(root,"//relation") #debug
# Retrieve the pathway edges as dataFrame
tryCatch(dataList <- lapply(isRelation, parseRelation),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
relationRef <- do.call(rbind, dataList)
rm(dataList)
tryCatch(dataList <- lapply(isReaction, parseReaction),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-0
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
# reactions <- do.call(rbind, dataList)
reactionsRef <- do.call(rbind, lapply(dataList, `[[`, 1))
reactionsDef <- do.call(rbind, lapply(dataList, `[[`, 2))
rDupReaction <- do.call(rbind, lapply(dataList, `[[`, 3))
rDupReaction<-na.exclude(rDupReaction)
rm(dataList)
#separate enzimes from maps and compounds
if(dataType == 'ec'){
enzimes<-entryRef[entryRef$eType == 'enzyme',]
}else{
enzimes<-entryRef[entryRef$eType == 'gene',]
}
compounds<-entryRef[entryRef$eType == 'compound',]
compounds$cDesc<-''
# To maintain always the lower name
enzimes<-enzimes[order(enzimes$eName),]
#colapse alternative enzimes for the same reaction
nodes<-enzimes[!duplicated(enzimes[,c("eReaction")]),]
nodesDuplic<-enzimes[duplicated(enzimes[,c("eReaction")]),]
nodesDuplic<- merge(nodesDuplic, nodes[,c("eId","eName",
"eReaction",
"x","y")],
by="eReaction")
#nodes<-current_kgml$nodes
map <- pathwayinfo$number
i=2 #debug
#something is wrong with data?
if(isTRUE(is.null(nrow(compounds))) |
isTRUE(nrow(compounds) == 0) |
isTRUE(is.null(nrow(reactionsRef))) |
isTRUE(nrow(reactionsRef) == 0)|
isTRUE(is.null(nrow(enzimes))) |
isTRUE(nrow(enzimes) == 0) |
isTRUE(is.null(nrow(relationRef))) |
isTRUE(nrow(relationRef) == 0)){
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
return(0)
}
# EC ----
#Insert pathway information into database
pId <- do.call(rbind, insertPathInfo(pathwayinfo))[1]
enzimes$pId<-pId
compounds$pId<-pId
reactionsRef$pId<-pId
reactionsDef$pId<-pId
View(insertPathInfo)
KGML2Dataframe <- function(kgml_,
dataType,
dbCon) {
# Verify and process the KGML file
# tryCatch(doc <- xmlTreeParse(kgml_, getDTD = FALSE, error = xmlErrorCumulator(immediate = FALSE)),
#        error = function(e) {
#          fileSize <- file.info(kgml_)$size[1]
#          bytes <- sprintf("%d byte%s", fileSize, ifelse(fileSize >
#                                                           1, "s", ""))
#          msg <- paste("The file", kgml_, "seems not to be a valid KGML file\n")
#          if (fileSize < 100L)
#            msg <- paste(msg, "[WARNING] File size (", bytes,
#                         ") is unsually small; please check.\n", sep = "")
#          msg <- paste(msg, "\nDetailed error messages from",
#                       "XML::xmlTreeParse:\n", sep = "")
#          cat(msg)
#          stop(e)
#        })
error <<- 0
tryCatch(doc <- read_xml(kgml_, getDTD = FALSE, error = xmlErrorCumulator(immediate = FALSE)),
error = function(e) {
fileSize <- file.info(kgml_)$size[1]
bytes <- sprintf("%d byte%s", fileSize, ifelse(fileSize >
1, "s", ""))
msg <- paste("The file", kgml_, "seems not to be a valid KGML file\n")
if (fileSize < 100L)
msg <- paste(msg, "[WARNING] File size (", bytes,
") is unsually small; please check.\n", sep = "")
msg <- paste(msg, "\nDetailed error messages from",
"XML::xmlTreeParse:\n", sep = "")
cat(msg)
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n",msg,'\n')
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
# Retrieve the XML root
root <- xml_root(doc)
#r1<- read_xml(kgml_)
#childnames <- sapply(xml_children(root), xml_name)
# # r[[1]]
# # r[[2]]
# #
# # l<-seq(700,800,1)
# # length(xmlChildren(r))
#    r<-removeChildren(node = r,kids = s)
# #
# # saveXML(r, file = file.path(folder,"01teste.xml"))
# # r[[1]]
# # r[[2]]
#
# # Retrieve the XML root children
# childnames <- sapply(xmlChildren(r), xmlName)
#
# r[names(r)=="entry"]
#
# s<-xml_find_first(r1,"//entry[@id='33']")
#
# xml_attr(s,"id")<-"33"
#
# xml_remove(s)
# write_xml(r1,file = "/home/clovis/Projetos/GrupoDalmolin/Igor/gitAPs/data/kgml/ec/01teste.xml")
#
# getNodeSet(r1, "//entry[@id='48']")
# Define which children are entries
isEntry<-xml_find_all(root,"//entry")
#isEntry <- childnames == "entry"
# Define which children are relations
isRelation<-xml_find_all(root,"//relation")
# isRelation <- childnames == "relation"
# Define which children are reactions
isReaction<-xml_find_all(root,"//reaction")
# isReaction <- childnames == "reaction"
# Retrieve the pathway info as dataFrame
pathwayinfo <- parsePathwayInfo(root)
map <- sub(x = pathwayinfo$name, pattern = "path:",replacement = '')
entry<-xml_find_first(root,"//entry[@name='ec:2.7.1.1']") #debug
#entry<-isEntry[[1]] #debug
# Retrieve the pathway entries as dataFrame
tryCatch(dataList <- lapply(isEntry, parseEntry),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
#rearange in dataframes
entryRef <- do.call(rbind, lapply(dataList, `[[`, 1))
entryMap <- do.call(rbind, lapply(dataList, `[[`, 2))
dupEntry <- do.call(rbind, lapply(dataList, `[[`, 3))
dupEntry<-na.exclude(dupEntry)
eDupReaction <- do.call(rbind, lapply(dataList, `[[`, 4))
eDupReaction<-na.exclude(eDupReaction)
rm(dataList)
relation<-xml_find_first(root,"//relation") #debug
# Retrieve the pathway edges as dataFrame
tryCatch(dataList <- lapply(isRelation, parseRelation),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
relationRef <- do.call(rbind, dataList)
rm(dataList)
# Retrieve the pathway reactions as dataFrame
tryCatch(dataList <- lapply(isReaction, parseReaction),
error = function(e) {
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
error<<-0
error<<-1
return(NULL)
})
if(error != 0){
return(0)
}
# reactions <- do.call(rbind, dataList)
reactionsRef <- do.call(rbind, lapply(dataList, `[[`, 1))
reactionsDef <- do.call(rbind, lapply(dataList, `[[`, 2))
rDupReaction <- do.call(rbind, lapply(dataList, `[[`, 3))
rDupReaction<-na.exclude(rDupReaction)
rm(dataList)
#separate enzimes from maps and compounds
if(dataType == 'ec'){
enzimes<-entryRef[entryRef$eType == 'enzyme',]
}else{
enzimes<-entryRef[entryRef$eType == 'gene',]
}
compounds<-entryRef[entryRef$eType == 'compound',]
compounds$cDesc<-''
# #remove duplicated pair enzime + reaction
# enzimes<-enzimes[!duplicated(enzimes[,c("eName","eReaction")]),]
# To maintain always the lower name
enzimes<-enzimes[order(enzimes$eName),]
#colapse alternative enzimes for the same reaction
nodes<-enzimes[!duplicated(enzimes[,c("eReaction")]),]
nodesDuplic<-enzimes[duplicated(enzimes[,c("eReaction")]),]
nodesDuplic<- merge(nodesDuplic, nodes[,c("eId","eName",
"eReaction",
"x","y")],
by="eReaction")
#nodes<-current_kgml$nodes
map <- pathwayinfo$number
i=2 #debug
# dbDisconnect(dbCon) #debug
# dbCon <- dbConnect(RSQLite::SQLite(), dbFile)#debug
#something is wrong with data?
if(isTRUE(is.null(nrow(compounds))) |
isTRUE(nrow(compounds) == 0) |
isTRUE(is.null(nrow(reactionsRef))) |
isTRUE(nrow(reactionsRef) == 0)|
isTRUE(is.null(nrow(enzimes))) |
isTRUE(nrow(enzimes) == 0) |
isTRUE(is.null(nrow(relationRef))) |
isTRUE(nrow(relationRef) == 0)){
cat("\tError processing", basename(kgml_), "file.\n")
cat(file = logFile, append = T,
"\tError processing", basename(kgml_), "file.\n")
return(0)
}
if(dataType == 'ec'){
# EC ----
#Insert pathway information into database
pId <- do.call(rbind, insertPathInfo(pathwayinfo))[1]
enzimes$pId<-pId
compounds$pId<-pId
reactionsRef$pId<-pId
reactionsDef$pId<-pId
# compoundsNId <- do.call(rbind,
#                apply(X = compounds,
#                      MARGIN = 1,
#                      insertCompound))
#
# ltEnzReac<-list(enzimes,reactionsRef,
#                 reactionsDef, compoundsNId,
#                 pId) #debug
# ltEnzReac <- insertEnzReac(list(enzimes,reactionsRef,
#                    reactionsDef, compoundsNId,
#                    pId))
#
# enzimes2<-ltEnzReac[[1]]
# reactionsRef2 <- ltEnzReac[[2]]
# reactionsDef2 <- ltEnzReac[[3]]
#
# #remove all maplinks
# relationRef2 <- relationRef[relationRef$type == "ECrel",]
# #get entry1 newId
# relationRef2<- merge(relationRef2,
#                      enzimes2[,c("newId","oldId")],
#                      by.x = "entry1",
#                      by.y = "oldId",
#                      all.x = T)
# colnames(relationRef2)[c(1,6)] <- c("eOldId1","eNewId1")
# #get entry2 newId
# relationRef2<- merge(relationRef2,
#                      enzimes2[,c("newId","oldId")],
#                      by.x = "entry2",
#                      by.y = "oldId",
#                      all.x = T)
# colnames(relationRef2)[c(1,7)] <- c("eOldId2","eNewId2")
# #get compound newId
# relationRef2 <- merge(relationRef2,
#                       compoundsNId[,c("newId","oldId")],
#                       by.x = "value",
#                       by.y = "oldId",
#                       all.x = T)
# colnames(relationRef2)[c(1,8)] <-c("cOldId","cNewId")
#
# relationRef2 <- na.exclude(relationRef2)
#
# relationRef3 <- do.call(rbind,
#                         apply(X = relationRef2,
#                               MARGIN = 1,
#                               insertRelation))
#
entryMap$map<-NULL
entryMap$graphicalType<-NULL
entryMap$width<-NULL
entryMap$height<-NULL
entryMap$fgcolor<-NULL
entryMap$bgcolor<-NULL
entryMap$pId<-pId
entryMap$orgId<-dataType
#remove ORTHOLOGY links
entryMap<-entryMap[!entryMap$mLink %in%
entryMap$mLink[grep(pattern = 'www_bget[?]K',
x = entryMap$mLink)],]
#remove compound links
entryMap<-entryMap[!entryMap$mLink %in%
entryMap$mLink[grep(pattern = 'www_bget[?]C',
x = entryMap$mLink)],]
#remove map links
entryMap<-entryMap[!entryMap$mLink %in%
entryMap$mLink[grep(pattern = 'www_bget[?]ec',
x = entryMap$mLink)],]
apply(X = entryMap,
MARGIN = 1,
insertMap)
}else{
# other orgs ----
#process organism information
pId <- do.call(rbind,
getPathInfo(pathwayinfo = pathwayinfo,
orgName = dataType))[1]
enzimes$pId<-pId
enzimes$org <- dataType
compounds$pId<-pId
reactionsRef$pId<-pId
reactionsRef$org <- dataType
reactionsDef$pId<-pId
apply(X = reactionsRef,
MARGIN = 1,
insertReactionOrg)
#prepare entryMap to insertion
#map<-entryMap
entryMap$map<-NULL
entryMap$graphicalType<-NULL
entryMap$width<-NULL
entryMap$height<-NULL
entryMap$fgcolor<-NULL
entryMap$bgcolor<-NULL
entryMap$pId<-pId
entryMap$orgId<-dataType
#remove ORTHOLOGY links
entryMap<-entryMap[!entryMap$mLink %in%
entryMap$mLink[grep(pattern = 'www_bget[?]K',
x = entryMap$mLink)],]
#remove compound links
entryMap<-entryMap[!entryMap$mLink %in%
entryMap$mLink[grep(pattern = 'www_bget[?]C',
x = entryMap$mLink)],]
#remove map links
entryMap<-entryMap[!entryMap$mLink %in%
entryMap$mLink[grep(pattern = 'www_bget[?]ec',
x = entryMap$mLink)],]
apply(X = entryMap,
MARGIN = 1,
insertMap)
}
return(1)
}
# read xml files and load data to database
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = T)
# read xml files and load data to database
generateDataFromKGML(dirBase = dirBase,
dataType = 'ec',
skip = F)
