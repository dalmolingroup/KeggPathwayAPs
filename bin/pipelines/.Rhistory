vis.nodes$associatedEnzymes = "";
vis.nodes$associatedReactions = "";
# Get the total orgs for the current pathway
totalOrg <- getTotalOrgs(pId)
vis.nodes$totalOrg = totalOrg
# Get the frequency for each pathway
for (idx in 1:nrow(vis.nodes)) {
vis.nodes[idx,]$freq = countNodeFrequency(vis.nodes[idx,]$nId, pId)
vis.nodes[idx,]$percentage = (vis.nodes[idx,]$freq / totalOrg) * 100
# Get the nodes associated enzymes and reactions
createDbConnection()
associatedEnzymes <- getAssociatedEnzymes(vis.nodes[idx,]$name, paste0("ec", pathway_))
associatedReactions <- getAssociatedReactions(vis.nodes[idx,]$name, paste0("ec", pathway_))
if (!is.null(associatedEnzymes) && length(associatedEnzymes) != 0) {
tempEnzymes = ""
for (idx2 in 1:nrow(associatedEnzymes)) {
tempEnzymes <- paste0(tempEnzymes, "<br>", associatedEnzymes[idx2,]$enzymeName)
}
vis.nodes[idx,]$associatedEnzymes <- tempEnzymes
}
if (!is.null(associatedReactions) && length(associatedReactions) != 0) {
tempReactions = ""
for (idx2 in 1:nrow(associatedReactions)) {
tempReactions <- paste0(tempReactions, "<br>", associatedReactions[idx2,]$rName)
}
vis.nodes[idx,]$associatedReactions <- tempReactions
}
}
# Max frequency in a pathway
pathwayMaxFrequency <- max(vis.nodes$percentage)
# Min frequency in a pathway
pathwayMinFrequency <- min(vis.nodes$percentage)
# Normalized frequency for each protein
vis.nodes$nPercent = (vis.nodes$percentage - pathwayMinFrequency) /
(pathwayMaxFrequency - pathwayMinFrequency) * 100
# Define the nodes group
vis.nodes$group = vis.nodes$isAP
if (sum(vis.nodes$group == 1, na.rm = T) > 0) {
vis.nodes[vis.nodes$group == 1,]$group <- 'AP'
}
if (sum(vis.nodes$group == 0, na.rm = T) > 0) {
vis.nodes[vis.nodes$group == 0,]$group <- 'Non-AP'
}
# Set the initial nodes attributes
vis.nodes$color.border <- "white"
vis.nodes$borderWidth <- 0
# Apply the border color by bottleneck status
vis.nodes$color.border[which(vis.nodes$isAP == 0)] <- "white"
vis.nodes$color.border[which(vis.nodes$isAP == 1)] <- "blue"
vis.nodes$borderWidth[which(vis.nodes$isAP == 0)] <- 2 # Node border width
vis.nodes$borderWidth[which(vis.nodes$isAP == 1)] <- 4 # AP Node border width
vis.nodes$id     <- vis.nodes$nId # Node ID
vis.nodes$label  <- vis.nodes$name # Node label
#vis.nodes$label  <- paste0(vis.nodes$name, "\n(", vis.nodes$AP_classification, ")") # Node label
vis.nodes$title  <- paste0("EC: ", vis.nodes$name, "<br>",
#"Entrez: ", vis.nodes$entrez, "<hr>",
#"Classification: ", vis.nodes$AP_classification, "<br>",
"Is AP: ", ifelse(vis.nodes$isAP==1, 'Yes', 'No') , "<br>",
"AP impact: ", vis.nodes$bottleneckImpact, "<br>",
"Disconnected components: ", vis.nodes$bottleneckDisconnectedComponents, "<hr>",
"Community: ", vis.nodes$community, "<br>",
"Degree: ", vis.nodes$degree, "<br>",
"Betweenness: ", format(round(vis.nodes$betweenness, 4), nsmall = 4), "<br>",
"Clustering coefficient: ", format(round(vis.nodes$clusteringCoef, 4), nsmall = 4), "<br>",
"Closeness coefficient: ", format(round(vis.nodes$closenessCoef, 4), nsmall = 4), "<br>",
"Authority score: ", vis.nodes$authorityScore, "<br>",
"Hub score: ", vis.nodes$hubScore, "<hr>",
"Frequency: ", format(round(vis.nodes$percentage, 2), nsmall = 2), "% <hr>",
"Associated enzymes: ", vis.nodes$associatedEnzymes, "<hr>",
"Associated reactions: ", vis.nodes$associatedReactions, "<hr>",
"More info: ", vis.nodes$link) # Text on click,
vis.nodes$shadow <- TRUE # Nodes will drop shadow
# Properties when node highlighted
vis.nodes$color.highlight.background <- "orange"
vis.nodes$color.highlight.border <- "darkred"
vis.nodes$color.highlight.background[which(vis.nodes$isAP == 1)] <- "#20639B"
vis.nodes$color.highlight.border[which(vis.nodes$isAP == 1)] <- "#173F5F"
betweennessScaleValues <- 1
# Replace NA values
if (sum(is.na(vis.nodes$betweenness), na.rm = T) > 0) {
vis.nodes[is.na(vis.nodes$betweenness),]$betweenness = 0
}
tryCatch({
# Generates the background color scale
betweennessScaleValues <- cut(vis.nodes$betweenness, breaks = seq(min(vis.nodes$betweenness),
max(vis.nodes$betweenness), len = 100),
include.lowest = TRUE)
}, error=function(e) {})
# Apply the background color scale
vis.nodes$color.background <- colorRampPalette(pal)(99)[betweennessScaleValues]
# Apply node size according to its frequency
vis.nodes$size <- scales::rescale(vis.nodes$percentage, to=c(10, 30))
# Set network links properties
vis.links$width <- 1 # line width
vis.links$arrows <- "middle" # arrows: 'from', 'to', or 'middle'
vis.links$smooth <- TRUE    # should the edges be curved?
vis.links$shadow <- FALSE    # edge shadow
# line color
vis.links$color <- "gray"
if (sum(is.na(vis.links$reaction1Status), na.rm = T) > 0) {
vis.links[is.na(vis.links$reaction1Status),]$reaction1Status = 'reversible'
}
if (sum(vis.links$reaction1Status == 'reversible', na.rm = T) > 0) {
vis.links[vis.links$reaction1Status == 'reversible',]$edge_color <- "gray"
}
if (sum(vis.links$reaction1Status == 'irreversible', na.rm = T) > 0) {
vis.links[vis.links$reaction1Status == 'irreversible',]$edge_color <- "darkred"
}
# Conver the edge nodes Id to name
vis.links$nodeFrom = ''
vis.links$nodeTo = ''
for (idx in 1:nrow(vis.links)) {
vis.links[idx,]$nodeFrom = vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]$name
vis.links[idx,]$nodeTo = vis.nodes[vis.nodes$nId == vis.links[idx,]$to,]$name
}
View(vis.links)
idx
View(vis.nodes)
vis.links[idx,]
vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]
vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]$name
vis.nodes[vis.nodes$nId == vis.links[idx,]$to,]$name
vis.links[idx,]$to
View(data)
View(vis.nodes)
View(data)
data$edges
data$nodes
View(data$nodes)
View(networkProperties)
V(g4)$nId
pId
# Retrieve the network metrics
networkProperties <- getNodeMetrics(V(g4)$nId, pId)
nodeIds_ = V(g4)$nId
pathwayId_ = pId
values<-list(nodeIds_, pathwayId_)
View(values)
values[[1]]
# DB attributes
table <- "nodemetric"
fields <- c("nId", "pId")
values<-list(nodeIds_, pathwayId_)
searchValue <- function(table, fields, values){
if(length(fields) != length(values)){
stop("Fields and values must have same length.")
}
sql<-paste0('SELECT *
FROM ',table,
' WHERE ')
for(idx in 1:length(fields)){
if (class(values[idx]) == "list" && length(unlist(values[idx])) > 1) {
sql<- paste0(sql,fields[idx],' IN (', sapply(values[idx], paste, collapse=", "), ')')
} else {
sql<- paste0(sql,fields[idx],' = ', values[idx])
}
if(idx != length(fields)){
sql<- paste0(sql,' and ')
}
}
resQuery <- dbGetQuery(dbCon,sql)
cat(sql,' ',nrow(resQuery),'\n')
if(nrow(resQuery) > 1){
return(resQuery)
}else if(nrow(resQuery)==0){
return(0)
}else{
return(resQuery[[1]][[1]])
}
}
# Search in DB
resQuery <- searchValue(table, fields, values)
vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]$name
vis.nodes[vis.nodes$nId == vis.links[idx,]$to,]$name
vis.links[idx,]$from
vis.nodes$nId
data.nodes$nId
data$nodes$nId
vis.nodes[data$nodes$nId == vis.links[idx,]$from,]$name
currentNodeFrom
vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]$name
vis.links[idx,]$from
idx
vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]$name
vis.links[idx,]$from
data$nodes$nId
data$nodes$nId == vis.links[idx,]$from
data$nodes[data$nodes$nId == vis.links[idx,]$from,]$name
View(data)
data$nodes
data$nodes[data$nodes$nId == vis.links[idx,]$from,]$eName
vis.nodes[vis.nodes$nId == vis.links[idx,]$to,]$name
data$nodes[data$nodes$nId == vis.links[idx,]$to,]$eName
View(vis.links)
for (idx in 1:nrow(vis.links)) {
currentNodeFrom <- vis.nodes[vis.nodes$nId == vis.links[idx,]$from,]$name
currentNodeTo <- vis.nodes[vis.nodes$nId == vis.links[idx,]$to,]$name
if (length(currentNodeFrom) != 0) {
vis.links[idx,]$nodeFrom <- currentNodeFrom
} else {
vis.links[idx,]$nodeFrom <- data$nodes[data$nodes$nId == vis.links[idx,]$from,]$eName
}
if (length(currentNodeTo) != 0) {
vis.links[idx,]$nodeTo <- currentNodeTo
} else {
vis.links[idx,]$nodeTo <- data$nodes[data$nodes$nId == vis.links[idx,]$to,]$eName
}
}
# Loop 01: Run through all available organisms
lapply(orgList, function(org_) {
pathway_index <- 1
# Loop 02: Run through all available pathways
lapply(pathwayList, function(pathway_) {
createDbConnection()
# Adjust the pathway code
pathway_ = str_replace(pathway_, 'ec', '')
# Status message
printMessage(paste0("GENERATING ORG ", org_, ", PATHWAY ", pathway_, " INTERATIVE NETWORK [", pathway_index, " OF ", length(pathwayList), "]"))
# Just execute if the network don't exist
if (!file.exists(file.path(paste0(dirBase, '/output/network/', org_, '/', pathway_, '.html')))) {
# Generate the dynamic network
generatedNetwork <- showDynamicGraph(pathway_ = pathway_, org_ = org_,
auxInfo_ = T, label_ = "enzyme",
removeFake_ = T)
if (!is.null(generatedNetwork)) {
exportNetwork(generatedNetwork, pathway_, org_)
} else {
printMessage(paste0("Organism doesn't have this pathway, skipping it..."))
}
} else {
printMessage(paste0("Network already exists, skipping it..."))
}
# Increment the index
pathway_index <<- pathway_index + 1
}) # End of Loop 02
}) # End of Loop 01
#*******************************************#
# Pipeline to generate the dynamic networks #
#*******************************************#
# ---- IMPORT SECTION ----
# Clean all variables
rm(list=ls(all=TRUE))
# Import the necessary libraries
library(dplyr)
# Graph handling
library(igraph)
library(visNetwork)
# Graph plot
library(ggraph)
# Graph layouts
library(graphlayouts)
library(oaqc)
# Color pallete and scale
library(RColorBrewer)
library(viridis)
library(scales)
# Image export
library(svglite)
# Base location ----
# Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<<-"/media/igorbrandao/IGOR BACKUP SERVER/Arquivos Igor/Faculdades/UFRN/4 - Mestrado/Pesquisas/System biology approaches in the investigation of bottlenecks in KEGG pathways/KeggPathwayAPs"
#figures
dirFig<<-file.path(dirBase,"figures")
#bin dir
binDir<<-file.path(dirBase,"bin")
#function dir
funcDir<<-file.path(binDir,"functions")
#database folder and file
dbDir<<-file.path(dirBase,"data","database")
dbTemplate <- file.path(dbDir,"APs.sql")
dbFile<<-file.path(dbDir,"dictionary.db")
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Import the graphLoader functions
files.sources = NULL
files.sources[1] = paste0(funcDir, "/", "dynamicGraph.R")
sapply(files.sources, source)
#*******************************************************************************************#
# ---- SETTINGS SECTION ----
#*************************#
# Pipeline basic settings #
#*************************#
# Load the pathways by organisms data
orgList <- c("ec", "hsa", "mmu", "dme", "sce", "cel")
#orgList <- getOrgCounts()
#orgList <- orgList$org
# Create tge DB connection
createDbConnection()
# Load the paythway list
pathwayList <- getAllPathways()
# Reduce the pathway list for testint purpose
#pathwayList = pathwayList[1:5]
#*******************************************************************************************#
# ---- PIPELINE SECTION ----
#***************#
# Pipeline flow #
#***************#
# Loop 01: Run through all available organisms
lapply(orgList, function(org_) {
pathway_index <- 1
# Loop 02: Run through all available pathways
lapply(pathwayList, function(pathway_) {
createDbConnection()
# Adjust the pathway code
pathway_ = str_replace(pathway_, 'ec', '')
# Status message
printMessage(paste0("GENERATING ORG ", org_, ", PATHWAY ", pathway_, " INTERATIVE NETWORK [", pathway_index, " OF ", length(pathwayList), "]"))
# Just execute if the network don't exist
if (!file.exists(file.path(paste0(dirBase, '/output/network/', org_, '/', pathway_, '.html')))) {
# Generate the dynamic network
generatedNetwork <- showDynamicGraph(pathway_ = pathway_, org_ = org_,
auxInfo_ = T, label_ = "enzyme",
removeFake_ = T)
if (!is.null(generatedNetwork)) {
exportNetwork(generatedNetwork, pathway_, org_)
} else {
printMessage(paste0("Organism doesn't have this pathway, skipping it..."))
}
} else {
printMessage(paste0("Network already exists, skipping it..."))
}
# Increment the index
pathway_index <<- pathway_index + 1
}) # End of Loop 02
}) # End of Loop 01
# End ----
#*******************************************#
# Pipeline to generate the dynamic networks #
#*******************************************#
# ---- IMPORT SECTION ----
# Clean all variables
rm(list=ls(all=TRUE))
# Import the necessary libraries
library(dplyr)
# Graph handling
library(igraph)
library(visNetwork)
# Graph plot
library(ggraph)
# Graph layouts
library(graphlayouts)
library(oaqc)
# Color pallete and scale
library(RColorBrewer)
library(viridis)
library(scales)
# Image export
library(svglite)
# Base location ----
# Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<<-"/media/igorbrandao/IGOR BACKUP SERVER/Arquivos Igor/Faculdades/UFRN/4 - Mestrado/Pesquisas/System biology approaches in the investigation of bottlenecks in KEGG pathways/KeggPathwayAPs"
#figures
dirFig<<-file.path(dirBase,"figures")
#bin dir
binDir<<-file.path(dirBase,"bin")
#function dir
funcDir<<-file.path(binDir,"functions")
#database folder and file
dbDir<<-file.path(dirBase,"data","database")
dbTemplate <- file.path(dbDir,"APs.sql")
dbFile<<-file.path(dbDir,"dictionary.db")
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Import the graphLoader functions
files.sources = NULL
files.sources[1] = paste0(funcDir, "/", "dynamicGraph.R")
sapply(files.sources, source)
#*******************************************************************************************#
# ---- SETTINGS SECTION ----
#*************************#
# Pipeline basic settings #
#*************************#
# Load the pathways by organisms data
orgList <- c("ec", "hsa", "mmu", "dme", "sce", "cel")
#orgList <- getOrgCounts()
#orgList <- orgList$org
# Create tge DB connection
createDbConnection()
# Load the paythway list
pathwayList <- getAllPathways()
# Reduce the pathway list for testint purpose
#pathwayList = pathwayList[1:5]
#*******************************************************************************************#
# ---- PIPELINE SECTION ----
#***************#
# Pipeline flow #
#***************#
# Loop 01: Run through all available organisms
lapply(orgList, function(org_) {
pathway_index <- 1
# Loop 02: Run through all available pathways
lapply(pathwayList, function(pathway_) {
createDbConnection()
# Adjust the pathway code
pathway_ = str_replace(pathway_, 'ec', '')
# Status message
printMessage(paste0("GENERATING ORG ", org_, ", PATHWAY ", pathway_, " INTERATIVE NETWORK [", pathway_index, " OF ", length(pathwayList), "]"))
# Just execute if the network don't exist
if (!file.exists(file.path(paste0(dirBase, '/output/network/', org_, '/', pathway_, '.html')))) {
# Generate the dynamic network
generatedNetwork <- showDynamicGraph(pathway_ = pathway_, org_ = org_,
auxInfo_ = T, label_ = "enzyme",
removeFake_ = T)
if (!is.null(generatedNetwork)) {
exportNetwork(generatedNetwork, pathway_, org_)
} else {
printMessage(paste0("Organism doesn't have this pathway, skipping it..."))
}
} else {
printMessage(paste0("Network already exists, skipping it..."))
}
# Increment the index
pathway_index <<- pathway_index + 1
}) # End of Loop 02
}) # End of Loop 01
# End ----
#*******************************************#
# Pipeline to generate the dynamic networks #
#*******************************************#
# ---- IMPORT SECTION ----
# Clean all variables
rm(list=ls(all=TRUE))
# Import the necessary libraries
library(dplyr)
# Graph handling
library(igraph)
library(visNetwork)
# Graph plot
library(ggraph)
# Graph layouts
library(graphlayouts)
library(oaqc)
# Color pallete and scale
library(RColorBrewer)
library(viridis)
library(scales)
# Image export
library(svglite)
# Base location ----
# Did you change it to your base location?
dirBase<-"Place here the correct name of your work folder"
dirBase<<-"/media/igorbrandao/IGOR BACKUP SERVER/Arquivos Igor/Faculdades/UFRN/4 - Mestrado/Pesquisas/System biology approaches in the investigation of bottlenecks in KEGG pathways/KeggPathwayAPs"
#figures
dirFig<<-file.path(dirBase,"figures")
#bin dir
binDir<<-file.path(dirBase,"bin")
#function dir
funcDir<<-file.path(binDir,"functions")
#database folder and file
dbDir<<-file.path(dirBase,"data","database")
dbTemplate <- file.path(dbDir,"APs.sql")
dbFile<<-file.path(dbDir,"dictionary.db")
# Import dependencies file to load dependencies and functions
source(file.path(funcDir,"dependencies.R"))
loadDependencies()
# Import the graphLoader functions
files.sources = NULL
files.sources[1] = paste0(funcDir, "/", "dynamicGraph.R")
sapply(files.sources, source)
#*******************************************************************************************#
# ---- SETTINGS SECTION ----
#*************************#
# Pipeline basic settings #
#*************************#
# Load the pathways by organisms data
orgList <- c("ec", "hsa", "mmu", "dme", "sce", "cel")
#orgList <- getOrgCounts()
#orgList <- orgList$org
# Create tge DB connection
createDbConnection()
# Load the paythway list
pathwayList <- getAllPathways()
# Reduce the pathway list for testint purpose
#pathwayList = pathwayList[1:5]
#*******************************************************************************************#
# ---- PIPELINE SECTION ----
#***************#
# Pipeline flow #
#***************#
# Loop 01: Run through all available organisms
lapply(orgList, function(org_) {
pathway_index <- 1
# Loop 02: Run through all available pathways
lapply(pathwayList, function(pathway_) {
createDbConnection()
# Adjust the pathway code
pathway_ = str_replace(pathway_, 'ec', '')
# Status message
printMessage(paste0("GENERATING ORG ", org_, ", PATHWAY ", pathway_, " INTERATIVE NETWORK [", pathway_index, " OF ", length(pathwayList), "]"))
# Just execute if the network don't exist
if (!file.exists(file.path(paste0(dirBase, '/output/network/', org_, '/', pathway_, '.html')))) {
# Generate the dynamic network
generatedNetwork <- showDynamicGraph(pathway_ = pathway_, org_ = org_,
auxInfo_ = T, label_ = "enzyme",
removeFake_ = T)
if (!is.null(generatedNetwork)) {
exportNetwork(generatedNetwork, pathway_, org_)
} else {
printMessage(paste0("Organism doesn't have this pathway, skipping it..."))
}
} else {
printMessage(paste0("Network already exists, skipping it..."))
}
# Increment the index
pathway_index <<- pathway_index + 1
}) # End of Loop 02
}) # End of Loop 01
# End ----
